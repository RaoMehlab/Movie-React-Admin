"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const graphql_1 = require("graphql");
const schema_1 = require("@graphql-tools/schema");
const utils_1 = require("@graphql-tools/utils");
const schema_2 = require("../schema");
const verify_database_1 = __importDefault(require("./utils/verify-database"));
const auth_1 = require("../auth");
const constants_1 = require("../constants");
const create_auth_param_1 = __importDefault(require("../translate/create-auth-param"));
const asserts_indexes_and_constraints_1 = __importDefault(require("./utils/asserts-indexes-and-constraints"));
const debug = debug_1.default(constants_1.DEBUG_GRAPHQL);
class Neo4jGraphQL {
    constructor(input) {
        const { config = {}, driver, resolvers, schemaDirectives, ...schemaDefinition } = input;
        const { nodes, relationships, schema } = schema_2.makeAugmentedSchema(schemaDefinition, {
            enableRegex: config.enableRegex,
            skipValidateTypeDefs: config.skipValidateTypeDefs,
        });
        this.driver = driver;
        this.config = config;
        this.nodes = nodes;
        this.relationships = relationships;
        this.schema = schema;
        /*
            Order must be:

                addResolversToSchema -> visitSchemaDirectives -> createWrappedSchema

            addResolversToSchema breaks schema directives added before it

            createWrappedSchema must come last so that all requests have context prepared correctly
        */
        if (resolvers) {
            if (Array.isArray(resolvers)) {
                resolvers.forEach((r) => {
                    this.schema = schema_1.addResolversToSchema(this.schema, r);
                });
            }
            else {
                this.schema = schema_1.addResolversToSchema(this.schema, resolvers);
            }
        }
        if (schemaDirectives) {
            utils_1.SchemaDirectiveVisitor.visitSchemaDirectives(this.schema, schemaDirectives);
        }
        this.schema = this.createWrappedSchema({ schema: this.schema, config });
        this.document = graphql_1.parse(graphql_1.printSchema(schema));
    }
    createWrappedSchema({ schema, config, }) {
        return schema_1.addSchemaLevelResolver(schema, async (obj, _args, context, resolveInfo) => {
            const { driverConfig } = config;
            if (debug.enabled) {
                const query = graphql_1.print(resolveInfo.operation);
                debug("%s", `Incoming GraphQL:\nQuery:\n${query}\nVariables:\n${JSON.stringify(resolveInfo.variableValues, null, 2)}`);
            }
            /*
                Deleting this property ensures that we call this function more than once,
                See https://github.com/ardatan/graphql-tools/issues/353#issuecomment-499569711
            */
            // @ts-ignore: Deleting private property from object
            delete resolveInfo.operation.__runAtMostOnce; // eslint-disable-line no-param-reassign,no-underscore-dangle
            if (!(context === null || context === void 0 ? void 0 : context.driver)) {
                if (!this.driver) {
                    throw new Error("A Neo4j driver instance must either be passed to Neo4jGraphQL on construction, or passed as context.driver in each request.");
                }
                context.driver = this.driver;
            }
            if (!(context === null || context === void 0 ? void 0 : context.driverConfig)) {
                context.driverConfig = driverConfig;
            }
            context.neoSchema = this;
            if (!context.jwt) {
                context.jwt = await auth_1.getJWT(context);
            }
            context.auth = create_auth_param_1.default({ context });
            context.queryOptions = config.queryOptions;
            return obj;
        });
    }
    async checkNeo4jCompat(input = {}) {
        var _a;
        const driver = input.driver || this.driver;
        const driverConfig = input.driverConfig || ((_a = this.config) === null || _a === void 0 ? void 0 : _a.driverConfig);
        if (!driver) {
            throw new Error("neo4j-driver Driver missing");
        }
        return verify_database_1.default({ driver, driverConfig });
    }
    async assertIndexesAndConstraints(input = {}) {
        var _a;
        const driver = input.driver || this.driver;
        const driverConfig = input.driverConfig || ((_a = this.config) === null || _a === void 0 ? void 0 : _a.driverConfig);
        if (!driver) {
            throw new Error("neo4j-driver Driver missing");
        }
        await asserts_indexes_and_constraints_1.default({ driver, driverConfig, nodes: this.nodes, options: input.options });
    }
}
exports.default = Neo4jGraphQL;
//# sourceMappingURL=Neo4jGraphQL.js.map