"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const merge_1 = require("@graphql-tools/merge");
const schema_1 = require("@graphql-tools/schema");
const utils_1 = require("@graphql-tools/utils");
const graphql_1 = require("graphql");
const graphql_compose_1 = require("graphql-compose");
const pluralize_1 = __importDefault(require("pluralize"));
const classes_1 = require("../classes");
const constants = __importStar(require("../constants"));
const utils_2 = require("../utils/utils");
const create_connection_fields_1 = __importDefault(require("./create-connection-fields"));
const create_relationship_fields_1 = __importDefault(require("./create-relationship-fields"));
const get_auth_1 = __importDefault(require("./get-auth"));
const get_custom_resolvers_1 = __importDefault(require("./get-custom-resolvers"));
const get_obj_field_meta_1 = __importDefault(require("./get-obj-field-meta"));
const get_where_fields_1 = __importDefault(require("./get-where-fields"));
const parse_exclude_directive_1 = __importDefault(require("./parse-exclude-directive"));
const parse_node_directive_1 = __importDefault(require("./parse-node-directive"));
const parse_fulltext_directive_1 = __importDefault(require("./parse/parse-fulltext-directive"));
const point = __importStar(require("./point"));
const resolvers_1 = require("./resolvers");
const Scalars = __importStar(require("./scalars"));
const to_compose_1 = require("./to-compose");
const validation_1 = require("./validation");
const get_unique_fields_1 = __importDefault(require("./get-unique-fields"));
const aggregation_types_mapper_1 = require("./aggregations/aggregation-types-mapper");
function makeAugmentedSchema({ typeDefs, ...schemaDefinition }, { enableRegex, skipValidateTypeDefs } = {}) {
    const document = merge_1.mergeTypeDefs(Array.isArray(typeDefs) ? typeDefs : [typeDefs]);
    if (!skipValidateTypeDefs) {
        validation_1.validateDocument(document);
    }
    const composer = new graphql_compose_1.SchemaComposer();
    // graphql-compose will break if the Point and CartesianPoint types are created but not used,
    // because it will purge the unused types but leave behind orphaned field resolvers
    //
    // These are flags to check whether the types are used and then create them if they are
    let pointInTypeDefs = false;
    let cartesianPointInTypeDefs = false;
    let relationships = [];
    composer.createObjectTC({
        name: "CreateInfo",
        fields: {
            bookmark: graphql_1.GraphQLString,
            nodesCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
        },
    });
    composer.createObjectTC({
        name: "DeleteInfo",
        fields: {
            bookmark: graphql_1.GraphQLString,
            nodesDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
        },
    });
    composer.createObjectTC({
        name: "UpdateInfo",
        fields: {
            bookmark: graphql_1.GraphQLString,
            nodesCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            nodesDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
        },
    });
    const aggregationTypesMapper = new aggregation_types_mapper_1.AggregationTypesMapper(composer);
    composer.createInputTC({
        name: "QueryOptions",
        fields: {
            offset: "Int",
            limit: "Int",
        },
    });
    const sortDirection = composer.createEnumTC({
        name: "SortDirection",
        values: {
            ASC: {
                value: "ASC",
                description: "Sort by field values in ascending order.",
            },
            DESC: {
                value: "DESC",
                description: "Sort by field values in descending order.",
            },
        },
    });
    composer.createObjectTC({
        name: "PageInfo",
        description: "Pagination information (Relay)",
        fields: {
            hasNextPage: "Boolean!",
            hasPreviousPage: "Boolean!",
            startCursor: "String",
            endCursor: "String",
        },
    });
    const customResolvers = get_custom_resolvers_1.default(document);
    const scalars = document.definitions.filter((x) => x.kind === "ScalarTypeDefinition");
    const objectNodes = document.definitions.filter((x) => x.kind === "ObjectTypeDefinition" && !["Query", "Mutation", "Subscription"].includes(x.name.value));
    const enums = document.definitions.filter((x) => x.kind === "EnumTypeDefinition");
    const inputs = document.definitions.filter((x) => x.kind === "InputObjectTypeDefinition");
    let interfaces = document.definitions.filter((x) => x.kind === "InterfaceTypeDefinition");
    const directives = document.definitions.filter((x) => x.kind === "DirectiveDefinition");
    const unions = document.definitions.filter((x) => x.kind === "UnionTypeDefinition");
    const relationshipPropertyInterfaceNames = new Set();
    const interfaceRelationshipNames = new Set();
    const extraDefinitions = [
        ...enums,
        ...scalars,
        ...directives,
        ...inputs,
        ...unions,
        ...[
            customResolvers.customQuery,
            customResolvers.customMutation,
            customResolvers.customSubscription,
        ],
    ].filter(Boolean);
    Object.keys(Scalars).forEach((scalar) => composer.addTypeDefs(`scalar ${scalar}`));
    if (extraDefinitions.length) {
        composer.addTypeDefs(graphql_1.print({ kind: "Document", definitions: extraDefinitions }));
    }
    const nodes = objectNodes.map((definition) => {
        var _a;
        const otherDirectives = (definition.directives || []).filter((x) => !["auth", "exclude", "node", "fulltext"].includes(x.name.value));
        const authDirective = (definition.directives || []).find((x) => x.name.value === "auth");
        const excludeDirective = (definition.directives || []).find((x) => x.name.value === "exclude");
        const nodeDirectiveDefinition = (definition.directives || []).find((x) => x.name.value === "node");
        const fulltextDirectiveDefinition = (definition.directives || []).find((x) => x.name.value === "fulltext");
        const nodeInterfaces = [...(definition.interfaces || [])];
        const { interfaceAuthDirectives, interfaceExcludeDirectives } = nodeInterfaces.reduce((res, interfaceName) => {
            const iface = interfaces.find((i) => i.name.value === interfaceName.name.value);
            if (iface) {
                const interfaceAuthDirective = (iface.directives || []).find((x) => x.name.value === "auth");
                const interfaceExcludeDirective = (iface.directives || []).find((x) => x.name.value === "exclude");
                if (interfaceAuthDirective) {
                    res.interfaceAuthDirectives.push(interfaceAuthDirective);
                }
                if (interfaceExcludeDirective) {
                    res.interfaceExcludeDirectives.push(interfaceExcludeDirective);
                }
            }
            return res;
        }, { interfaceAuthDirectives: [], interfaceExcludeDirectives: [] });
        if (interfaceAuthDirectives.length > 1) {
            throw new Error(`Multiple interfaces of ${definition.name.value} have @auth directive - cannot determine directive to use`);
        }
        if (interfaceExcludeDirectives.length > 1) {
            throw new Error(`Multiple interfaces of ${definition.name.value} have @exclude directive - cannot determine directive to use`);
        }
        let auth;
        if (authDirective || interfaceAuthDirectives.length) {
            auth = get_auth_1.default(authDirective || interfaceAuthDirectives[0]);
        }
        let exclude;
        if (excludeDirective || interfaceExcludeDirectives.length) {
            exclude = parse_exclude_directive_1.default(excludeDirective || interfaceExcludeDirectives[0]);
        }
        let nodeDirective;
        if (nodeDirectiveDefinition) {
            nodeDirective = parse_node_directive_1.default(nodeDirectiveDefinition);
        }
        const nodeFields = get_obj_field_meta_1.default({
            obj: definition,
            enums,
            interfaces,
            scalars,
            unions,
            objects: objectNodes,
        });
        let fulltextDirective;
        if (fulltextDirectiveDefinition) {
            fulltextDirective = parse_fulltext_directive_1.default({
                directive: fulltextDirectiveDefinition,
                nodeFields,
                definition,
            });
        }
        nodeFields.relationFields.forEach((relationship) => {
            if (relationship.properties) {
                const propertiesInterface = interfaces.find((i) => i.name.value === relationship.properties);
                if (!propertiesInterface) {
                    throw new Error(`Cannot find interface specified in ${definition.name.value}.${relationship.fieldName}`);
                }
                relationshipPropertyInterfaceNames.add(relationship.properties);
            }
            if (relationship.interface) {
                interfaceRelationshipNames.add(relationship.typeMeta.name);
            }
        });
        if (!pointInTypeDefs) {
            pointInTypeDefs = nodeFields.pointFields.some((field) => field.typeMeta.name === "Point");
        }
        if (!cartesianPointInTypeDefs) {
            cartesianPointInTypeDefs = nodeFields.pointFields.some((field) => field.typeMeta.name === "CartesianPoint");
        }
        const node = new classes_1.Node({
            name: definition.name.value,
            interfaces: nodeInterfaces,
            otherDirectives,
            ...nodeFields,
            // @ts-ignore we can be sure it's defined
            auth,
            // @ts-ignore we can be sure it's defined
            exclude,
            // @ts-ignore we can be sure it's defined
            nodeDirective,
            // @ts-ignore we can be sure it's defined
            fulltextDirective,
            description: (_a = definition.description) === null || _a === void 0 ? void 0 : _a.value,
        });
        return node;
    });
    const relationshipProperties = interfaces.filter((i) => relationshipPropertyInterfaceNames.has(i.name.value));
    const interfaceRelationships = interfaces.filter((i) => interfaceRelationshipNames.has(i.name.value));
    interfaces = interfaces.filter((i) => !(relationshipPropertyInterfaceNames.has(i.name.value) || interfaceRelationshipNames.has(i.name.value)));
    const relationshipFields = new Map();
    relationshipProperties.forEach((relationship) => {
        var _a;
        const authDirective = (relationship.directives || []).find((x) => x.name.value === "auth");
        if (authDirective) {
            throw new Error("Cannot have @auth directive on relationship properties interface");
        }
        (_a = relationship.fields) === null || _a === void 0 ? void 0 : _a.forEach((field) => {
            constants.RESERVED_INTERFACE_FIELDS.forEach(([fieldName, message]) => {
                if (field.name.value === fieldName) {
                    throw new Error(message);
                }
            });
            const forbiddenDirectives = ["auth", "relationship", "cypher"];
            forbiddenDirectives.forEach((directive) => {
                const found = (field.directives || []).find((x) => x.name.value === directive);
                if (found) {
                    throw new Error(`Cannot have @${directive} directive on relationship property`);
                }
            });
        });
        const relFields = get_obj_field_meta_1.default({
            enums,
            interfaces,
            objects: objectNodes,
            scalars,
            unions,
            obj: relationship,
        });
        if (!pointInTypeDefs) {
            pointInTypeDefs = relFields.pointFields.some((field) => field.typeMeta.name === "Point");
        }
        if (!cartesianPointInTypeDefs) {
            cartesianPointInTypeDefs = relFields.pointFields.some((field) => field.typeMeta.name === "CartesianPoint");
        }
        relationshipFields.set(relationship.name.value, relFields);
        const objectComposeFields = to_compose_1.objectFieldsToComposeFields(Object.values(relFields).reduce((acc, x) => [...acc, ...x], []));
        const propertiesInterface = composer.createInterfaceTC({
            name: relationship.name.value,
            fields: objectComposeFields,
        });
        composer.createInputTC({
            name: `${relationship.name.value}Sort`,
            fields: propertiesInterface.getFieldNames().reduce((res, f) => {
                return { ...res, [f]: "SortDirection" };
            }, {}),
        });
        composer.createInputTC({
            name: `${relationship.name.value}UpdateInput`,
            fields: [
                ...relFields.primitiveFields.filter((field) => !field.autogenerate && !field.readonly),
                ...relFields.scalarFields,
                ...relFields.enumFields,
                ...relFields.temporalFields.filter((field) => !field.timestamps),
                ...relFields.pointFields,
            ].reduce((res, f) => ({
                ...res,
                [f.fieldName]: f.typeMeta.input.update.pretty,
            }), {}),
        });
        const relationshipWhereFields = get_where_fields_1.default({
            typeName: relationship.name.value,
            fields: {
                scalarFields: relFields.scalarFields,
                enumFields: relFields.enumFields,
                temporalFields: relFields.temporalFields,
                pointFields: relFields.pointFields,
                primitiveFields: relFields.primitiveFields,
            },
            enableRegex,
        });
        composer.createInputTC({
            name: `${relationship.name.value}Where`,
            fields: relationshipWhereFields,
        });
        composer.createInputTC({
            name: `${relationship.name.value}CreateInput`,
            // TODO - This reduce duplicated when creating node CreateInput - put into shared function?
            fields: [
                ...relFields.primitiveFields.filter((field) => !field.autogenerate),
                ...relFields.scalarFields,
                ...relFields.enumFields,
                ...relFields.temporalFields.filter((field) => !field.timestamps),
                ...relFields.pointFields,
            ].reduce((res, f) => {
                var _a, _b;
                if (((_a = f) === null || _a === void 0 ? void 0 : _a.defaultValue) !== undefined) {
                    const field = {
                        type: f.typeMeta.input.create.pretty,
                        defaultValue: (_b = f) === null || _b === void 0 ? void 0 : _b.defaultValue,
                    };
                    res[f.fieldName] = field;
                }
                else {
                    res[f.fieldName] = f.typeMeta.input.create.pretty;
                }
                return res;
            }, {}),
        });
    });
    function ensureNonEmptyInput(nameOrInput) {
        const input = utils_2.isString(nameOrInput) ? composer.getITC(nameOrInput) : nameOrInput;
        if (input.getFieldNames().length === 0) {
            const faqURL = `https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/`;
            input.addFields({
                _emptyInput: {
                    type: "Boolean",
                    description: `Appears because this input type would be empty otherwise because this type is ` +
                        `composed of just generated and/or relationship properties. See ${faqURL}`,
                },
            });
        }
    }
    interfaceRelationships.forEach((interfaceRelationship) => {
        const implementations = objectNodes.filter((n) => { var _a; return (_a = n.interfaces) === null || _a === void 0 ? void 0 : _a.some((i) => i.name.value === interfaceRelationship.name.value); });
        const interfaceFields = get_obj_field_meta_1.default({
            enums,
            interfaces: [...interfaces, ...interfaceRelationships],
            objects: objectNodes,
            scalars,
            unions,
            obj: interfaceRelationship,
        });
        if (!pointInTypeDefs) {
            pointInTypeDefs = interfaceFields.pointFields.some((field) => field.typeMeta.name === "Point");
        }
        if (!cartesianPointInTypeDefs) {
            cartesianPointInTypeDefs = interfaceFields.pointFields.some((field) => field.typeMeta.name === "CartesianPoint");
        }
        const objectComposeFields = to_compose_1.objectFieldsToComposeFields(Object.values(interfaceFields).reduce((acc, x) => [...acc, ...x], []));
        const composeInterface = composer.createInterfaceTC({
            name: interfaceRelationship.name.value,
            fields: objectComposeFields,
        });
        const interfaceWhereFields = get_where_fields_1.default({
            typeName: interfaceRelationship.name.value,
            fields: {
                scalarFields: interfaceFields.scalarFields,
                enumFields: interfaceFields.enumFields,
                temporalFields: interfaceFields.temporalFields,
                pointFields: interfaceFields.pointFields,
                primitiveFields: interfaceFields.primitiveFields,
            },
            enableRegex,
            isInterface: true,
        });
        const [implementationsConnectInput, implementationsDeleteInput, implementationsDisconnectInput, implementationsUpdateInput, implementationsWhereInput,] = ["ConnectInput", "DeleteInput", "DisconnectInput", "UpdateInput", "Where"].map((suffix) => composer.createInputTC({
            name: `${interfaceRelationship.name.value}Implementations${suffix}`,
            fields: {},
        }));
        composer.createInputTC({
            name: `${interfaceRelationship.name.value}Where`,
            fields: { ...interfaceWhereFields, _on: implementationsWhereInput },
        });
        const interfaceCreateInput = composer.createInputTC(`${interfaceRelationship.name.value}CreateInput`);
        composer.getOrCreateITC(`${interfaceRelationship.name.value}UpdateInput`, (tc) => {
            tc.addFields({
                ...[
                    ...interfaceFields.primitiveFields,
                    ...interfaceFields.scalarFields,
                    ...interfaceFields.enumFields,
                    ...interfaceFields.temporalFields.filter((field) => !field.timestamps),
                    ...interfaceFields.pointFields,
                ].reduce((res, f) => {
                    var _a;
                    return f.readonly || ((_a = f) === null || _a === void 0 ? void 0 : _a.autogenerate)
                        ? res
                        : {
                            ...res,
                            [f.fieldName]: f.typeMeta.input.update.pretty,
                        };
                }, {}),
                _on: implementationsUpdateInput,
            });
        });
        create_relationship_fields_1.default({
            relationshipFields: interfaceFields.relationFields,
            schemaComposer: composer,
            composeNode: composeInterface,
            sourceName: interfaceRelationship.name.value,
            nodes,
            relationshipPropertyFields: relationshipFields,
        });
        relationships = [
            ...relationships,
            ...create_connection_fields_1.default({
                connectionFields: interfaceFields.connectionFields,
                schemaComposer: composer,
                composeNode: composeInterface,
                nodes,
                relationshipPropertyFields: relationshipFields,
            }),
        ];
        implementations.forEach((implementation) => {
            const node = nodes.find((n) => n.name === implementation.name.value);
            implementationsWhereInput.addFields({
                [implementation.name.value]: {
                    type: `${implementation.name.value}Where`,
                },
            });
            if (node.relationFields.length) {
                implementationsConnectInput.addFields({
                    [implementation.name.value]: {
                        type: `[${implementation.name.value}ConnectInput!]`,
                    },
                });
                implementationsDeleteInput.addFields({
                    [implementation.name.value]: {
                        type: `[${implementation.name.value}DeleteInput!]`,
                    },
                });
                implementationsDisconnectInput.addFields({
                    [implementation.name.value]: {
                        type: `[${implementation.name.value}DisconnectInput!]`,
                    },
                });
            }
            interfaceCreateInput.addFields({
                [implementation.name.value]: {
                    type: `${implementation.name.value}CreateInput`,
                },
            });
            implementationsUpdateInput.addFields({
                [implementation.name.value]: {
                    type: `${implementation.name.value}UpdateInput`,
                },
            });
        });
        if (implementationsConnectInput.getFieldNames().length) {
            const interfaceConnectInput = composer.getOrCreateITC(`${interfaceRelationship.name.value}ConnectInput`, (tc) => {
                tc.addFields({ _on: implementationsConnectInput });
            });
            interfaceConnectInput.setField("_on", implementationsConnectInput);
        }
        if (implementationsDeleteInput.getFieldNames().length) {
            const interfaceDeleteInput = composer.getOrCreateITC(`${interfaceRelationship.name.value}DeleteInput`, (tc) => {
                tc.addFields({ _on: implementationsDeleteInput });
            });
            interfaceDeleteInput.setField("_on", implementationsDeleteInput);
        }
        if (implementationsDisconnectInput.getFieldNames().length) {
            const interfaceDisconnectInput = composer.getOrCreateITC(`${interfaceRelationship.name.value}DisconnectInput`, (tc) => {
                tc.addFields({ _on: implementationsDisconnectInput });
            });
            interfaceDisconnectInput.setField("_on", implementationsDisconnectInput);
        }
        ensureNonEmptyInput(`${interfaceRelationship.name.value}CreateInput`);
        ensureNonEmptyInput(`${interfaceRelationship.name.value}UpdateInput`);
        [
            implementationsConnectInput,
            implementationsDeleteInput,
            implementationsDisconnectInput,
            implementationsUpdateInput,
            implementationsWhereInput,
        ].forEach((c) => ensureNonEmptyInput(c));
    });
    if (pointInTypeDefs) {
        // Every field (apart from CRS) in Point needs a custom resolver
        // to deconstruct the point objects we fetch from the database
        composer.createObjectTC(point.point);
        composer.createInputTC(point.pointInput);
        composer.createInputTC(point.pointDistance);
    }
    if (cartesianPointInTypeDefs) {
        // Every field (apart from CRS) in CartesianPoint needs a custom resolver
        // to deconstruct the point objects we fetch from the database
        composer.createObjectTC(point.cartesianPoint);
        composer.createInputTC(point.cartesianPointInput);
        composer.createInputTC(point.cartesianPointDistance);
    }
    unions.forEach((union) => {
        if (union.types && union.types.length) {
            const fields = union.types.reduce((f, type) => {
                return { ...f, [type.name.value]: `${type.name.value}Where` };
            }, {});
            composer.createInputTC({
                name: `${union.name.value}Where`,
                fields,
            });
        }
    });
    nodes.forEach((node) => {
        var _a, _b, _c, _d;
        const nodeFields = to_compose_1.objectFieldsToComposeFields([
            ...node.primitiveFields,
            ...node.cypherFields,
            ...node.enumFields,
            ...node.scalarFields,
            ...node.interfaceFields,
            ...node.objectFields,
            ...node.unionFields,
            ...node.temporalFields,
            ...node.pointFields,
            ...node.ignoredFields,
        ]);
        const composeNode = composer.createObjectTC({
            name: node.name,
            fields: nodeFields,
            description: node.description,
            directives: to_compose_1.graphqlDirectivesToCompose(node.otherDirectives),
            interfaces: node.interfaces.map((x) => x.name.value),
        });
        const sortFields = node.sortableFields.reduce((res, f) => ({
            ...res,
            [f.fieldName]: sortDirection.getTypeName(),
        }), {});
        if (Object.keys(sortFields).length) {
            const sortInput = composer.createInputTC({
                name: `${node.name}Sort`,
                fields: sortFields,
                description: `Fields to sort ${pluralize_1.default(node.name)} by. The order in which sorts are applied is not guaranteed when specifying many fields in one ${`${node.name}Sort`} object.`,
            });
            composer.createInputTC({
                name: `${node.name}Options`,
                fields: {
                    sort: {
                        description: `Specify one or more ${`${node.name}Sort`} objects to sort ${pluralize_1.default(node.name)} by. The sorts will be applied in the order in which they are arranged in the array.`,
                        type: sortInput.List,
                    },
                    limit: "Int",
                    offset: "Int",
                },
            });
        }
        else {
            composer.createInputTC({
                name: `${node.name}Options`,
                fields: { limit: "Int", offset: "Int" },
            });
        }
        const queryFields = get_where_fields_1.default({
            typeName: node.name,
            enableRegex,
            fields: {
                temporalFields: node.temporalFields,
                enumFields: node.enumFields,
                pointFields: node.pointFields,
                primitiveFields: node.primitiveFields,
                scalarFields: node.scalarFields,
            },
        });
        const countField = {
            type: "Int!",
            resolve: resolvers_1.numericalResolver,
            args: {},
        };
        composer.createObjectTC({
            name: `${node.name}AggregateSelection`,
            fields: {
                count: countField,
                ...[...node.primitiveFields, ...node.temporalFields].reduce((res, field) => {
                    if (field.typeMeta.array) {
                        return res;
                    }
                    const objectTypeComposer = aggregationTypesMapper.getAggregationType({
                        fieldName: field.typeMeta.name,
                        nullable: !field.typeMeta.required,
                    });
                    if (!objectTypeComposer)
                        return res;
                    res[field.fieldName] = objectTypeComposer.NonNull;
                    return res;
                }, {}),
            },
        });
        composer.createInputTC({
            name: `${node.name}Where`,
            fields: queryFields,
        });
        if (node.fulltextDirective) {
            const fields = node.fulltextDirective.indexes.reduce((res, index) => {
                return {
                    ...res,
                    [index.name]: composer.createInputTC({
                        name: `${node.name}${graphql_compose_1.upperFirst(index.name)}Fulltext`,
                        fields: {
                            phrase: "String!",
                            score_EQUAL: "Int",
                        },
                    }),
                };
            }, {});
            composer.createInputTC({
                name: `${node.name}Fulltext`,
                fields,
            });
        }
        const uniqueFields = get_unique_fields_1.default(node);
        composer.createInputTC({
            name: `${node.name}UniqueWhere`,
            fields: uniqueFields,
        });
        composer.createInputTC({
            name: `${node.name}CreateInput`,
            // TODO - This reduce duplicated when creating relationship CreateInput - put into shared function?
            fields: [
                ...node.primitiveFields,
                ...node.scalarFields,
                ...node.enumFields,
                ...node.temporalFields.filter((field) => !field.timestamps),
                ...node.pointFields,
            ].reduce((res, f) => {
                var _a, _b, _c;
                if ((_a = f) === null || _a === void 0 ? void 0 : _a.autogenerate) {
                    return res;
                }
                if (((_b = f) === null || _b === void 0 ? void 0 : _b.defaultValue) !== undefined) {
                    const field = {
                        type: f.typeMeta.input.create.pretty,
                        defaultValue: (_c = f) === null || _c === void 0 ? void 0 : _c.defaultValue,
                    };
                    res[f.fieldName] = field;
                }
                else {
                    res[f.fieldName] = f.typeMeta.input.create.pretty;
                }
                return res;
            }, {}),
        });
        composer.createInputTC({
            name: `${node.name}UpdateInput`,
            fields: [
                ...node.primitiveFields,
                ...node.scalarFields,
                ...node.enumFields,
                ...node.temporalFields.filter((field) => !field.timestamps),
                ...node.pointFields,
            ].reduce((res, f) => {
                var _a;
                return f.readonly || ((_a = f) === null || _a === void 0 ? void 0 : _a.autogenerate)
                    ? res
                    : {
                        ...res,
                        [f.fieldName]: f.typeMeta.input.update.pretty,
                    };
            }, {}),
        });
        ["Create", "Update"].map((operation) => composer.createObjectTC({
            name: `${operation}${node.getPlural({ camelCase: false })}MutationResponse`,
            fields: {
                info: `${operation}Info!`,
                [node.getPlural({ camelCase: true })]: `[${node.name}!]!`,
            },
        }));
        create_relationship_fields_1.default({
            relationshipFields: node.relationFields,
            schemaComposer: composer,
            composeNode,
            sourceName: node.name,
            nodes,
            relationshipPropertyFields: relationshipFields,
        });
        relationships = [
            ...relationships,
            ...create_connection_fields_1.default({
                connectionFields: node.connectionFields,
                schemaComposer: composer,
                composeNode,
                nodes,
                relationshipPropertyFields: relationshipFields,
            }),
        ];
        ensureNonEmptyInput(`${node.name}UpdateInput`);
        ensureNonEmptyInput(`${node.name}CreateInput`);
        if (!((_a = node.exclude) === null || _a === void 0 ? void 0 : _a.operations.includes("read"))) {
            composer.Query.addFields({
                [node.getPlural({ camelCase: true })]: resolvers_1.findResolver({ node }),
            });
            composer.Query.addFields({
                [`${node.getPlural({ camelCase: true })}Count`]: resolvers_1.countResolver({ node }),
            });
            composer.Query.addFields({
                [`${node.getPlural({ camelCase: true })}Aggregate`]: resolvers_1.aggregateResolver({ node }),
            });
        }
        if (!((_b = node.exclude) === null || _b === void 0 ? void 0 : _b.operations.includes("create"))) {
            composer.Mutation.addFields({
                [`create${node.getPlural({ camelCase: false })}`]: resolvers_1.createResolver({ node }),
            });
        }
        if (!((_c = node.exclude) === null || _c === void 0 ? void 0 : _c.operations.includes("delete"))) {
            composer.Mutation.addFields({
                [`delete${node.getPlural({ camelCase: false })}`]: resolvers_1.deleteResolver({ node }),
            });
        }
        if (!((_d = node.exclude) === null || _d === void 0 ? void 0 : _d.operations.includes("update"))) {
            composer.Mutation.addFields({
                [`update${node.getPlural({ camelCase: false })}`]: resolvers_1.updateResolver({ node, schemaComposer: composer }),
            });
        }
    });
    ["Mutation", "Query"].forEach((type) => {
        const objectComposer = composer[type];
        const cypherType = customResolvers[`customCypher${type}`];
        if (cypherType) {
            const objectFields = get_obj_field_meta_1.default({
                obj: cypherType,
                scalars,
                enums,
                interfaces,
                unions,
                objects: objectNodes,
            });
            const objectComposeFields = to_compose_1.objectFieldsToComposeFields([
                ...objectFields.enumFields,
                ...objectFields.interfaceFields,
                ...objectFields.primitiveFields,
                ...objectFields.relationFields,
                ...objectFields.scalarFields,
                ...objectFields.unionFields,
                ...objectFields.objectFields,
                ...objectFields.temporalFields,
            ]);
            objectComposer.addFields(objectComposeFields);
            objectFields.cypherFields.forEach((field) => {
                const customResolver = resolvers_1.cypherResolver({
                    field,
                    statement: field.statement,
                    type: type,
                });
                const composedField = to_compose_1.objectFieldsToComposeFields([field])[field.fieldName];
                objectComposer.addFields({ [field.fieldName]: { ...composedField, ...customResolver } });
            });
        }
    });
    interfaces.forEach((inter) => {
        var _a;
        const objectFields = get_obj_field_meta_1.default({ obj: inter, scalars, enums, interfaces, unions, objects: objectNodes });
        const objectComposeFields = to_compose_1.objectFieldsToComposeFields(Object.values(objectFields).reduce((acc, x) => [...acc, ...x], []));
        composer.createInterfaceTC({
            name: inter.name.value,
            description: (_a = inter.description) === null || _a === void 0 ? void 0 : _a.value,
            fields: objectComposeFields,
            directives: to_compose_1.graphqlDirectivesToCompose((inter.directives || []).filter((x) => !["auth", "exclude"].includes(x.name.value))),
        });
    });
    if (!Object.values(composer.Mutation.getFields()).length) {
        composer.delete("Mutation");
    }
    const generatedTypeDefs = composer.toSDL();
    let parsedDoc = graphql_1.parse(generatedTypeDefs);
    // @ts-ignore
    const documentNames = parsedDoc.definitions.filter((x) => "name" in x).map((x) => x.name.value);
    const generatedResolvers = {
        ...Object.entries(composer.getResolveMethods()).reduce((res, [key, value]) => {
            if (!documentNames.includes(key)) {
                return res;
            }
            return { ...res, [key]: value };
        }, {}),
        ...Object.entries(Scalars).reduce((res, [name, scalar]) => {
            if (generatedTypeDefs.includes(`scalar ${name}\n`)) {
                res[name] = scalar;
            }
            return res;
        }, {}),
    };
    unions.forEach((union) => {
        if (!generatedResolvers[union.name.value]) {
            // eslint-disable-next-line no-underscore-dangle
            generatedResolvers[union.name.value] = { __resolveType: (root) => root.__resolveType };
        }
    });
    interfaceRelationships.forEach((i) => {
        if (!generatedResolvers[i.name.value]) {
            // eslint-disable-next-line no-underscore-dangle
            generatedResolvers[i.name.value] = { __resolveType: (root) => root.__resolveType };
        }
    });
    const seen = {};
    parsedDoc = {
        ...parsedDoc,
        definitions: parsedDoc.definitions.filter((definition) => {
            var _a;
            if (!("name" in definition)) {
                return true;
            }
            const n = (_a = definition.name) === null || _a === void 0 ? void 0 : _a.value;
            if (seen[n]) {
                return false;
            }
            seen[n] = n;
            return true;
        }),
    };
    const schema = schema_1.makeExecutableSchema({
        ...schemaDefinition,
        typeDefs: parsedDoc,
        resolvers: generatedResolvers,
    });
    // Assign a default field resolver to account for aliasing of fields
    utils_1.forEachField(schema, (field) => {
        if (!field.resolve) {
            // eslint-disable-next-line no-param-reassign
            field.resolve = resolvers_1.defaultFieldResolver;
        }
    });
    return {
        nodes,
        relationships,
        schema,
    };
}
exports.default = makeAugmentedSchema;
//# sourceMappingURL=make-augmented-schema.js.map